#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "TimeLib" as TimeLib

#Include "Libs/BigBang1112/Layers.Script.txt" as Layers
#Include "Libs/BigBang1112/Manialink.Script.txt" as Manialink
#Include "Libs/BigBang1112/Settings.Script.txt" as Settings
#Include "Libs/BigBang1112/File.Script.txt" as File
#Include "Libs/BigBang1112/Dictionary.Script.txt" as Dictionary
#Include "Libs/BigBang1112/Task.Script.txt" as Task
#Include "Libs/BigBang1112/Map.Script.txt" as Map

#Include "Libs/Challenge/Loading.Script.txt" as Loading
#Include "Libs/Maker/MakerBase.Script.txt" as MakerBase
#Include "Libs/Maker/CampaignBuilder.Script.txt" as CampaignBuilder

#Struct SMetadata {
	Text Name;
	Text AuthorLogin;
	Text AuthorNickname;
	Text Description;
	Text CompatibleCollections;
}

#Struct SScriptInfo {
	Text Name;
	Text Type;
	SMetadata Metadata;
}

#Struct SChallenge {
	Text Name;
	Text Type;
}

#Struct SMapProgress {
	Boolean Modified;
	Boolean Computed;
	Integer Possible; // -1 - impossible, 0 - unknown, 1 - possible, 2 - solvable
	Integer Time;
}

#Struct SProgress {
	SMapProgress[Text][Text] Maps;
}

#Struct SChallengeMapInfo {
	Map::SMapInfo OriginalMap;
	Map::SMapInfo ModifiedMap;
	Integer Challenge;
	SMapProgress Progress;
}

Text ToDifferentChallengeMapName(Text _MapFileName, Text[] _Challenge) {
	declare DeconstructedMapName = TextLib::Split("\\",_MapFileName);
	declare ChallengeMapName = "";
	if(DeconstructedMapName.existskey(DeconstructedMapName.count-3)) {
		DeconstructedMapName[DeconstructedMapName.count-3] = TextLib::Join("+", _Challenge);
		ChallengeMapName = TextLib::Join("\\", DeconstructedMapName);
	}
	return ChallengeMapName;
}

SScriptInfo SChallengeToSScriptInfo(SChallenge _Challenge) {
	declare SScriptInfo Script;
	
	declare Text ScriptContent;
	
	Script.Name = _Challenge.Name;
	Script.Type = _Challenge.Type;
	if(_Challenge.Type == "Official") ScriptContent = File::Read("Media/Challenges/"^_Challenge.Name);
				
	declare LayerAPI = UILayerCreate();
	LayerAPI.ManialinkPage = Manialink::Construct("",File::Read("Media/API_Base.Script.txt")^"""
{{{Dictionary::TranslateAllPhrases(File::Read("Media/API.Script.txt"))}}}

{{{Dictionary::TranslateAllPhrases(ScriptContent)}}}

"""^File::Read("Media/API_Main_Metadata.Script.txt"));
	
	declare Received = False;
	while(!Received) {
		foreach(Event,PendingEvents) {
			if(LayerAPI == Event.CustomEventLayer) {
				declare SMetadata Metadata;
				declare JsonSuccess = Metadata.fromjson(Event.CustomEventData[0]);
				if(Metadata.AuthorLogin != "") {
					Script.Metadata = Metadata;
					Received = True;
					break;
				}
			}
		}
		yield;
	}
	
	UILayerDestroy(LayerAPI);
	
	return Script;
}

Void UpdateChallenges() {
	declare SChallenge[][] Challenges for This;
	declare SScriptInfo[][] Scripts for Layers::Page("Modifier");
	Scripts.clear();
	
	foreach(Challenge, Challenges) {
		declare SScriptInfo[] ChallengeScripts;
		foreach(SubChallenge, Challenge) {
			ChallengeScripts.add(SChallengeToSScriptInfo(SubChallenge));
		}
		Scripts.add(ChallengeScripts);
	}
}

Void UpdateTimings(Integer _TotalMapCount) {
	declare SProgress Progress for This;
	
	declare Integer CompletedCount for This;
	declare Integer TotalCount for This;
	declare Real TimeSpent for This;
	declare Real AvgLength for This;
	declare Real TimeLeft for This;
	
	CompletedCount = 0;
	TotalCount = _TotalMapCount;
	
	TimeSpent = 0.;
	foreach(OriMapUid => ModifiedUids, Progress.Maps) {
		foreach(ModifiedUid => ModifInfo, ModifiedUids) {
			if(ModifInfo.Time != -1) {
				TimeSpent += ModifInfo.Time;
				CompletedCount += 1;
			}
		}
	}
	
	Layers::SendEvent("Modifier", "UpdateTimeSpent", (TimeSpent*1000)^"");
	
	AvgLength = -1.;
	if(CompletedCount > 0) AvgLength = TimeSpent/CompletedCount;
	Layers::SendEvent("Modifier", "UpdateAvgLength", MathLib::NearestInteger(AvgLength*1000)^"");
	
	TimeLeft = -1.;
	if(TotalCount > 0 && AvgLength != -1) TimeLeft = AvgLength*(TotalCount-CompletedCount);
	Layers::SendEvent("Modifier", "UpdateTimeLeft", MathLib::NearestInteger(TimeLeft*1000)^"");
}

Void UpdateProgress() {
	declare SChallenge[][] Challenges for This; // JSON-defined picked challenges
	declare CMapInfo[] CampaignMaps for This;
	declare SProgress Progress for This;
	
	Layers::SendEvent("Modifier", "LoadingProgress", "0");
	
	declare CampaignBuilder::SCampaign[] Campaigns for This;
	CampaignMaps = CampaignBuilder::GetAllCampaignMaps(Campaigns);
	
	declare SScriptInfo[][] Scripts for Layers::Page("Modifier"); // Actual challenge scripts
	declare SChallengeMapInfo[] ChallengeMaps for Layers::Page("Modifier");
	ChallengeMaps.clear();
	
	declare Integer[Text] AmountLeft for This;
	AmountLeft = ["Modified" => 0, "Computed" => 0, "Possible" => 0];
	
	declare MapWaitSpace = 0;
	declare CurrentMapWaitSpace = 0;
	
	declare CurrentMap = 0.;
	foreach(Map,CampaignMaps) {
		declare ScriptId = 0;
		foreach(Script,Scripts) {
			declare SChallengeMapInfo MapInfo;
			MapInfo.OriginalMap = Map::ToSMapInfo(Map);
			MapInfo.Progress.Time = -1;
			
			declare Text[] Challenge;
			foreach(S, Script) Challenge.add(S.Metadata.Name);
				
			if(Progress.Maps.existskey(MapInfo.OriginalMap.MapUid)) {
				MapInfo.ModifiedMap = Map::MapInfo(ToDifferentChallengeMapName(Map.FileName, Challenge));
				
				if(Progress.Maps.existskey(Map.MapUid) && Progress.Maps[Map.MapUid].existskey(MapInfo.ModifiedMap.MapUid)) {
					MapInfo.Progress.Modified = Progress.Maps[Map.MapUid][MapInfo.ModifiedMap.MapUid].Modified;
					MapInfo.Progress.Computed = Progress.Maps[Map.MapUid][MapInfo.ModifiedMap.MapUid].Computed;
					MapInfo.Progress.Possible = Progress.Maps[Map.MapUid][MapInfo.ModifiedMap.MapUid].Possible;
					MapInfo.Progress.Time = Progress.Maps[Map.MapUid][MapInfo.ModifiedMap.MapUid].Time;
				}
			}
			
			if(!MapInfo.Progress.Modified) AmountLeft["Modified"] += 1;
			if(!MapInfo.Progress.Computed) AmountLeft["Computed"] += 1;
			if(MapInfo.Progress.Possible == 0 || MapInfo.Progress.Possible == 2) AmountLeft["Possible"] += 1;
		
			MapInfo.Challenge = ScriptId;
			ChallengeMaps.add(MapInfo);
			
			ScriptId+=1;
		}
		CurrentMap += 1;
		Layers::SendEvent("Modifier", "LoadingProgress", (CurrentMap/CampaignMaps.count)^"");
		
		if(CurrentMapWaitSpace > MapWaitSpace) {
			yield;
			CurrentMapWaitSpace = 0;
		}
		else CurrentMapWaitSpace += 1;
	}
	
	UpdateTimings(ChallengeMaps.count);
	Layers::SendEvent("Modifier", "UpdateAmountLeft", AmountLeft["Modified"]^"/"^AmountLeft["Possible"]);
	Layers::SendEvent("Modifier", "RefreshList");
}

Void UpdateFromFiles() {
	declare MakerBase::SChallengeTitleSettings Settings for This;
	declare JsonSettings = Settings.fromjson(File::Read("Media/Settings.json")); // Should be responsive
	
	declare SChallenge[][] Challenges for This;
	declare JsonChallenges = Challenges.fromjson(File::Read("Media/Challenges.json")); // Should be responsive
	
	declare CampaignBuilder::SCampaign[] Campaigns for This;
	declare JsonSuccess = Campaigns.fromjson(File::Read(CampaignBuilder::GetCampaignsFile())); // Should be responsive
}

Void Init() {
	Layers::Create("Modifier", Manialink::FromFile("Media/Manialinks/Maker/Modifier", True, ["Audio"], Settings::Get().Theme));
	Layers::Create("StartModifier", Manialink::FromFile("Media/Manialinks/Maker/StartModifier", True, ["Audio"], Settings::Get().Theme));
	
	UpdateFromFiles();
	
	declare MakerBase::SChallengeTitleSettings Settings for This;
	declare CampaignBuilder::SCampaign[] Campaigns for This;
	
	declare SProgress Progress for This;
	declare JsonProgress = Progress.fromjson(File::Read("Media/Progress.json"));
	
	declare Boolean IsReloaded for This;
	IsReloaded = False;
	
	UpdateChallenges();
}

Void Start() {

}

Void Event(CManiaAppEvent _Event) {
	declare Boolean IsUpdatingProgress for Layers::Page("Modifier");
	declare Boolean IsReloaded for This;

	declare Event <=> _Event;

	if(Event.Type == CManiaAppEvent::EType::LayerCustomEvent) {
		switch(Event.CustomEventLayer) {
			case Layers::Get("Modifier"): {
				switch(Event.CustomEventType) {
					case "Exit": {
						Layers::Hide("Modifier", False);
						Layers::Show("EditTitle", True);
						Layers::Show("ManageTitle", True);
					}
					case "Show": {
						UpdateFromFiles();
						IsUpdatingProgress = True;
					}
					case "ModifyMap": {
						declare MapId = TextLib::ToInteger(Event.CustomEventData[0]);
						
						declare SChallengeMapInfo[] ChallengeMaps for Layers::Page("Modifier");
						declare Map = ChallengeMaps[MapId];
						
						if(Map.Progress.Modified) {
							switch(Map.Progress.Possible) {
								case -1: {
									
								}
								case 0: {
									declare Integer[] ModificationIds for This;
									ModificationIds.add(MapId);
								}
								case 1: {
									// play
								}
								case 2: {
									declare Boolean RepairMap for This;
									declare Integer RepairMap_Id for This;
									declare SChallengeMapInfo RepairMap_Map for This;
									
									RepairMap = True;
									RepairMap_Id = MapId;
									RepairMap_Map = Map;
								}
							}
						}
						else {
							declare Integer[] ModificationIds for This;
							ModificationIds.add(MapId);
						}
					}
					case "Refresh": {
						UpdateFromFiles();
						IsUpdatingProgress = True;
						IsReloaded = False;
					}
					case "ModifyAll": {
						declare Integer CompletedCount for This;
						declare Integer TotalCount for This;
						declare Real TimeSpent for This;
						declare Real AvgLength for This;
						declare Real TimeLeft for This;
						
						declare Integer ComplCount for Layers::Page("StartModifier");
						declare Integer MaxCount for Layers::Page("StartModifier");
						declare Real AverageLength for Layers::Page("StartModifier");
						declare Integer UserComplCount for Layers::Page("StartModifier");
						
						ComplCount = CompletedCount;
						MaxCount = TotalCount;
						AverageLength = AvgLength;
						UserComplCount = MaxCount-ComplCount;
					
						Layers::Show("StartModifier", True);
					}
				}
			}
			case Layers::Get("StartModifier"): {
				switch(Event.CustomEventType) {
					case "Exit": {
						Layers::Hide("StartModifier", False);
					}
					case "Start": {
						declare Count = TextLib::ToInteger(Event.CustomEventData[0]);
						
						declare SChallengeMapInfo[] ChallengeMaps for Layers::Page("Modifier");
						
						declare Integer[] ModificationIds for This;
						
						declare Counter = 0;
						for(I,0,ChallengeMaps.count-1) {
							if(Counter == Count) break;
							if(!ChallengeMaps[I].Progress.Modified) {
								ModificationIds.add(I);
								Counter += 1;
							}
						}
					}
				}
			}
		}
	}
}

Void Async() {
	
}

Void Loop() {
	declare Integer[] ModificationIds for This;
	declare Boolean IsReloaded for This;
	
	declare ModificationCounter = 0;
	foreach(ModifId, ModificationIds) {
		if(ModificationCounter == 0)
			Layers::Hide("StartModifier", False); // When modification starts
	
		declare Time_ModificationStart = TimeLib::GetCurrent();
		
		declare SChallengeMapInfo[] ChallengeMaps for Layers::Page("Modifier");
		if(!ChallengeMaps.existskey(ModifId)) { continue; log(":thinking:"); }
		declare ChallengeMap = ChallengeMaps[ModifId];
		
		declare Map::SMapInfo OriginalMapInfo for LocalUser;
		OriginalMapInfo = ChallengeMap.OriginalMap;
		declare SScriptInfo[] CHALLENGE_SCRIPTS for LocalUser;
		declare SScriptInfo[][] Scripts for Layers::Page("Modifier");
		CHALLENGE_SCRIPTS = Scripts[ChallengeMap.Challenge];
					
		declare Text[] Challenges;
		foreach(Script, CHALLENGE_SCRIPTS) Challenges.add(Script.Metadata.Name);
		
		declare ChallengeMapName = ToDifferentChallengeMapName(ChallengeMap.OriginalMap.FileName, Challenges);
		Loading::SetLoading(ChallengeMap.OriginalMap.CollectionName, ChallengeMap.OriginalMap);
		
		wait(TitleControl.IsReady);
		TitleControl.EditNewMapFromBaseMap(ChallengeMap.OriginalMap.FileName, "", "", "Challenge.Script.txt", "Modifier.Script.txt", """<settings>
			<setting name="S_Build" type="boolean" value="True"/>
			<setting name="S_FastMode" type="boolean" value="True"/>
			<setting name="S_FastMode_MapSave" type="text" value="{{{ChallengeMapName}}}"/>
		</settings>""");
		wait(TitleControl.IsReady);
		wait(Map::Exists(ChallengeMapName));
		ChallengeMap.ModifiedMap = Map::MapInfo(ChallengeMapName);
		
		declare Time_ModificationEnd = TimeLib::GetCurrent();
		declare Delta = TimeLib::GetDelta(Time_ModificationEnd, Time_ModificationStart);
		
		declare Integer ProblemResult for LocalUser;
		
		// define Modified and Possible
		ChallengeMap.Progress.Modified = True;
		ChallengeMap.Progress.Possible = ProblemResult; // wrong
		ChallengeMap.Progress.Time = Delta;
		
		ChallengeMaps[ModifId] = ChallengeMap;
		
		// set some progress.json
		declare SProgress Progress for This;
		if(!Progress.Maps.existskey(ChallengeMap.OriginalMap.MapUid)) Progress.Maps[ChallengeMap.OriginalMap.MapUid] = [];
		Progress.Maps[ChallengeMap.OriginalMap.MapUid][ChallengeMap.ModifiedMap.MapUid] = ChallengeMap.Progress;
		TitleEdition.File_WriteText("Media/Progress.json",Progress.tojson());
		
		// Update all of the timings
		UpdateTimings(ChallengeMaps.count);
		
		declare Integer[Text] AmountLeft for This;
		if(ChallengeMap.Progress.Modified) AmountLeft["Modified"] -= 1;
		if(ChallengeMap.Progress.Computed) AmountLeft["Computed"] -= 1;
		if(ChallengeMap.Progress.Possible == -1 || ChallengeMap.Progress.Possible == 1) AmountLeft["Possible"] -= 1;
		Layers::SendEvent("Modifier", "UpdateAmountLeft", AmountLeft["Modified"]^"/"^AmountLeft["Possible"]);
		
		// Refresh the look of the list
		Layers::SendEvent("Modifier", "RefreshList");
			
		ModificationCounter += 1;
		
		if(ModificationCounter == ModificationIds.count) {
			// when modification ends
		}
	}
	if(ModificationIds.count > 0) ModificationIds.clear();
	
	declare Boolean IsUpdatingProgress for Layers::Page("Modifier");
	if(IsUpdatingProgress) {
		if(!IsReloaded) {
			UpdateProgress();
			IsReloaded = True;
		}
		IsUpdatingProgress = False;
	}
	
	declare Boolean RepairMap for This;
	if(RepairMap) {
		declare Integer RepairMap_Id for This;
		declare SChallengeMapInfo RepairMap_Map for This;
		
		Loading::SetLoading(RepairMap_Map.ModifiedMap.CollectionName, RepairMap_Map.ModifiedMap);
		TitleControl.EditMap(RepairMap_Map.ModifiedMap.FileName, "Modifier.Script.txt", """<settings>
	<setting name="S_Build" type="boolean" value="True"/>
	<setting name="S_FastMode_MapSave" type="text" value="{{{RepairMap_Map.ModifiedMap.FileName}}}"/>
</settings>""");
		wait(TitleControl.IsReady);
		RepairMap_Map.ModifiedMap = Map::MapInfo(RepairMap_Map.ModifiedMap.FileName);
		
		declare SChallengeMapInfo[] ChallengeMaps for Layers::Page("Modifier");
		
		declare Integer ProblemResult for LocalUser;
		
		// define Possible
		RepairMap_Map.Progress.Possible = ProblemResult; // wrong
		
		ChallengeMaps[RepairMap_Id] = RepairMap_Map;
		
		// set some progress.json
		declare SProgress Progress for This;
		if(!Progress.Maps.existskey(RepairMap_Map.OriginalMap.MapUid)) Progress.Maps[RepairMap_Map.OriginalMap.MapUid] = [];
		Progress.Maps[RepairMap_Map.OriginalMap.MapUid][RepairMap_Map.ModifiedMap.MapUid] = RepairMap_Map.Progress;
		TitleEdition.File_WriteText("Media/Progress.json",Progress.tojson());
		
		// Update all of the timings
		UpdateTimings(ChallengeMaps.count);
		
		declare Integer[Text] AmountLeft for This;
		if(RepairMap_Map.Progress.Modified) AmountLeft["Modified"] -= 1;
		if(RepairMap_Map.Progress.Computed) AmountLeft["Computed"] -= 1;
		if(RepairMap_Map.Progress.Possible == -1 || RepairMap_Map.Progress.Possible == 1) AmountLeft["Possible"] -= 1;
		Layers::SendEvent("Modifier", "UpdateAmountLeft", AmountLeft["Modified"]^"/"^AmountLeft["Possible"]);
		
		// Refresh the look of the list
		Layers::SendEvent("Modifier", "RefreshList");
		
		RepairMap = False;
	}
}